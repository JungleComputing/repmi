package applications.tsp;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedList;

import applications.util.Dimacs;
import applications.util.DistanceTable;

import joinc.Task;
import joinc.Master;

/**
 * JOINC master application that uses multiple workers to solve a single 
 * Travelling Salesman Problem (TSP). In this problem, the shortest path 
 * through a given number of cities must be determined, starting and ending in 
 * the same city. 
 * 
 * This master splits the initial problem by generating a number of partial 
 * solutions, which are then explored further by the workers. The shortest path 
 * is selected from the results returned by the workers. This is the answer to 
 * the complete problem.   
 * 
 * The jobs generated by this master have the following properties: 
 * 
 *    - all jobs compute a different part of a single large problem 
 *    - the jobs have a single input file (containing info on the cities)
 *    - the jobs get a number of command line parameters 
 *    - the jobs produce a single output file       
 *    - jobs use the best result found by previous jobs to optimize their search
 *    - there are large difference in job run times
 *  
 * @author Jason Maassen
 * @version 2.0 Feb 8, 2006
 * @since 1.0
 */
public class TSPMaster extends Master {

    private static final boolean VERBOSE = false;

    // The file containing the distance table
    private final String tableFile;

    // The name of the jar file containing the worker
    private final String workerJar;

    // The maximum number of workers to use
    private final int maxWorkers;

    // Start time of the master
    private final long startTime;

    // The distance table
    private final DistanceTable distanceTable;

    // The initial search depth used to generate the tasks
    private final int maxDepth;

    // The total number of tasks generated
    private final int totalTasks;

    // The number of tasks finished
    private int tasksFinished;

    // Number of tasks failed (e.g., output not found/unreadable/incomplete)
    private int tasksFailed;
    
    // Decription of failed tasks
    private ArrayList taskErrors = new ArrayList();
    
    // The next task that will be started
    private int taskIndex = 0;

    // List containing all tasks
    private LinkedList tasks = new LinkedList();

    // The length of the current best solution
    private int minimum = Integer.MAX_VALUE;

    // The path of the current best solution
    private int [] solution;

    // The number of hops that actually where searched
    private long totalStatesDone = 0;

    // The total time spend by the workers
    private long totalWorkerTime = 0;

    // The last status line printed
    private int lastFinishedPrint = 0;
    private int lastWaitingPrint = 0;
    
    // Create a TSPMaster
    private TSPMaster(String workerJar, String tableFile, int maxWorkers)
            throws Exception {

        this.tableFile = tableFile;
        this.workerJar = workerJar;
        this.maxWorkers = maxWorkers;
        
        // Read the distance file
        distanceTable = new Dimacs(tableFile).getTable();

        if (distanceTable.cities <= 20) { 
            maxDepth = 1;
        } else {        
            maxDepth = 1 + (distanceTable.cities-20); 
        }
        
        solution = null;

        // Come up with an estimation for the solution
        estimateSolution();
        
        // Now generate all tasks at once
        generateTasks();

        // How many tasks where generated ?
        totalTasks = tasks.size();

        // And finally print some information
        System.out.println("TSP Master started.");
        System.out.println("Using city file  : " + tableFile);
        System.out.println("Using worker jar : " + workerJar);
        System.out.println("Number of tasks  : " + totalTasks);
        System.out.print("Initial tour     : [");
        
        // Print the estimate
        for (int i = 0; i < distanceTable.cities; i++) {
            if (i != distanceTable.cities - 1) {
                System.out.print(solution[i] + ", ");
            } else {
                System.out.println(solution[i] + "]");
            }
        }
        
        System.out.println("Initial length   : " + minimum);
                
        // Now press start on the stopwatch
        startTime = System.currentTimeMillis();
    }

    /*
     * (non-Javadoc)
     * 
     * @see joinc.Master#getTask()
     */
    public Task getTask() {
        Task task = (Task) tasks.removeFirst();
        task.parameters[2] = "" + minimum;

        if (VERBOSE) {
            System.err.println("Returned task " + task.taskNumber);
            System.err.println("Set task minimum to " + minimum);
        }

        // Print some stuff to keep the user up to date
        printStatus(false);
        return task;
    }

    /*
     * (non-Javadoc)
     * 
     * @see joinc.Master#totalTasks()
     */
    public int totalTasks() {
        return totalTasks;
    }

    /*
     * (non-Javadoc)
     * 
     * @see joinc.Master#maximumWorkers()
     */
    public int maximumWorkers() {
        return maxWorkers;
    }

    /*
     * (non-Javadoc)
     * 
     * @see joinc.Master#idle()
     */
    public void idle() {
        // Give the user something to look at.
        printStatus(true);
    }

    /*
     * (non-Javadoc)
     * 
     * @see joinc.Master#taskDone(joinc.Task)
     */
    public void taskDone(Task task) {

        if (VERBOSE) {
            System.err.println("Task " + task.taskNumber + " done");
        }

        // Count the number of finished tasks
        tasksFinished++;
        
        // Just remove stderr and stdout
        deleteFile(task.stdoutFile);
        deleteFile(task.stderrFile);

        // Read the result ...
        readResult(task.outputFiles[0], task.taskNumber);
                           
        // ... and remove the result file
        deleteFile(task.outputFiles[0]);

        // Give the user something to look at.
        printStatus(false);
    }

    
    /**
     * Quickly generates a 'reasonable' solution. This is use to give the first 
     * tasks a chance to optimize a bit.   
     */
    private void estimateSolution() {
        
        int [] path = new int[distanceTable.cities];        
        
        path[0] = 1;
        path[1] = 2;
        path[2] = 3;
        
        int len = distanceTable.distance(1,2) + distanceTable.distance(2,3) +  
            distanceTable.distance(3,1);        
                
        for (int i=4;i<=distanceTable.cities;i++) {
        
            if (VERBOSE) {    
                System.out.print("[ ");
                for (int j=0;j<i-1;j++) { 
                    System.out.print(path[j] + " (" +         
                            distanceTable.distance(path[j], path[(j+1)%(i-1)]) + 
                    ") ");
                }
                
                System.out.println("1 ]: " + len);                     
            }
            
            len = insert(path, i, i-1, len);
        }
        
        minimum = len;
        solution = path;
    }

    /**
     * Insert a new city into an existing tour is such a position that the 
     * increase in tour length is as small as possible.  
     * 
     * @param path current tour (content will be changed by this call)
     * @param newCity city to add
     * @param pathLength number of cities in current tour
     * @param len length of current tour
     * @return length of new tour
     */
    private int insert(int [] path, int newCity, int pathLength, int len) { 
        
        int best = 0;
        int bestDiff = Integer.MAX_VALUE;
               
        for (int i=0;i<pathLength;i++) { 
            
            int remove = distanceTable.distance(path[i], path[(i+1)%pathLength]);         
            int add = distanceTable.distance(path[i], newCity) +  
                  distanceTable.distance(newCity, path[(i+1)%pathLength]);
       
            if ((add-remove) < bestDiff) { 
                bestDiff = (add-remove);
                best = i+1;
            }            
        }

        // Move all higher cities by one. 
        for (int i=pathLength-1;i>=best;i--) { 
            path[i+1] = path[i];
        }
        
        // Insert new city
        path[best] = newCity;
        
        // Return new length
        return (len + bestDiff);
    }
    
    /**
     * Generate the tasks by partially solving tsp.
     */
    private void generateTasks() {
        int[] path = new int[distanceTable.cities];

        path[0] = 1;
        distributor(0, path);
    }

    /**
     * Recursively compute a route up to a certain depth.
     * 
     * @param depth current search depth
     * @param path current partial path 
     */
    private void distributor(int depth, int[] path) {

        if (depth == maxDepth - 1) {
            // The initial search depth has been reached. Now store the
            // task so it can be run on the grid later.
            createTask(path, taskIndex++);
            return;
        }

        // Add a hop to the initial path, and continue searching
        for (int i = 1; i < distanceTable.cities; i++) {
            if (!present(i, depth, path)) {
                path[depth + 1] = i;
                distributor(depth + 1, path);
            }
        }
    }

    /**
     * Generate a Task object containing all information to complete this task
     * on a worker. 
     * 
     * @param path the partial path that the worker should investigate 
     * @param taskNumber number of this task
     */
    private void createTask(int[] path, int taskNumber) {

        // Start by creating names for the output files
        String stdout = "stdout." + taskNumber;
        String stderr = "stderr." + taskNumber;
        String outputFile = "result." + taskNumber;

        // Next, generate the parameters
        String[] parameters = new String[4 + maxDepth];
        parameters[0] = tableFile;
        parameters[1] = outputFile;
        parameters[2] = null; // Filled in later!
        parameters[3] = "" + maxDepth;

        for (int i = 0; i < maxDepth; i++) {
            parameters[4 + i] = "" + path[i];
        }

        if (VERBOSE) {
            System.err.print("Created task " + tableFile + " " + outputFile
                    + " " + minimum + " ");

            for (int i = 0; i < maxDepth; i++) {
                System.err.print(" " + path[i]);
            }

            System.err.println();
        }

        // Then create a Task object containing this info.
        Task task = new Task("applications.tsp.TSPWorker", stdout, stderr,
                "/dev/null", parameters, new String[] { workerJar },
                new String[] { tableFile }, new String[] { outputFile });

        // Finally, store this object in the tasks list
        tasks.add(task);
    }


    /**
     * Checks if a certain city is present is a path.
     * 
     * @param city the city to check
     * @param length the length of the path 
     * @param path the path to check 
     * 
     * @return boolean that indicates if city is present in path
     */
    private final boolean present(int city, int length, int[] path) {
        // is a city present in a path ?
        for (int i = length; i >= 0; i--) {
            if (path[i] == city)
                return true;
        }

        return false;
    }

    /**
     * Prints the current solution. 
     */
    private void printSolution() { 
        // Create the line to print
        StringBuffer out = new StringBuffer("Found solution : [");
        
        // ... showing the current solution
        for (int i = 0; i < distanceTable.cities; i++) {
            out.append(solution[i]);
            
            if (i != distanceTable.cities - 1) {
                out.append(", ");
            } else {
                out.append("] (length ");
            }
        }
        
        // ... and the minimum
        out.append(minimum + ")");        
        System.out.println(out.toString());
    }
    
    /**
     * Prints some status information, so the user has something to look at 
     * while waiting. The mayWait parameter indicates if the method is allowed 
     * to wait for a few seconds. This prevent the application eating too much
     * CPU when idle is called repeatedly.  
     * 
     * @param mayWait indicates if the method may sleep for a while 
     */    
    private void printStatus(boolean mayWait) {
        
        int tasksWaiting = tasks.size();
        int tasksRunning = totalTasks - (tasksWaiting + tasksFinished);
                
        if (tasksFinished == lastFinishedPrint && 
                lastWaitingPrint == tasksWaiting) {
            
            // nothing new to print...
            if (mayWait) { 
                try { 
                    Thread.sleep(2000);
                } catch (Exception e) {
                    // ignore
                }                
            }            
            return;
        }
                               
        StringBuffer out = new StringBuffer("Tasks waiting ");
        out.append(tasksWaiting);    
        out.append(" / running ");        
        out.append(tasksRunning);
        out.append(" / finished ");        
        out.append(tasksFinished);
        
        // Remember what we printed, so we don't print things twice
        lastFinishedPrint = tasksFinished;
        lastWaitingPrint = tasksWaiting;
        
        // ... and finally print it!
        System.out.println(out.toString());
    }

    /**
     * Delete a file.
     * 
     * @param filename file to delete.
     */
    private void deleteFile(String filename) {
        File file = new File(filename);
        file.delete();
    }

    /**
     * Converts a line of tekst into a path. 
     * 
     * @param line text to convert
     * @return the path
     */
    private int [] readTour(String line) { 
        
        int [] tour = new int[distanceTable.cities+1];
        
        for (int i=0;i<distanceTable.cities;i++) {
            int nextSpace = line.indexOf(" ");            
            String city = line.substring(0, nextSpace).trim();
            line = line.substring(nextSpace+1).trim();            
            tour[i] = Integer.parseInt(city);
        }

        tour[tour.length-1] = 1;
        return tour;
    }
    
    /**
     * Read an output file produced by the worker. 
     * The following four lines are expected: 
     * 
     *   Minimum tour: <string>
     *   Minimum tour lenght: <number>
     *   Total computation time: <double>
     *   Total states examined: <number>
     *
     * Any other lines that may be printed will be ignored by this parser. 
     * 
     * If the file is missing or could not be parsed, the result will be 
     * rejected. The masters will remeber this and print an error at the end of 
     * the run.  
     * 
     * @param filename worker output file to read.
     * @param taskNumber task that produced this file. 
     */    
    private void readResult(String filename, int taskNumber) {
        
        int [] currentSolution = null;
        int currentLength = -1;        
        long time = -1;
        long states = -1;
        
        try {
            BufferedReader reader = new BufferedReader(new FileReader(filename));
            
            String line = reader.readLine();
            
            while (line != null) {
                
                if (line.startsWith("Minimum tour: ")) { 
                    currentSolution = readTour(line.substring(14));
                } else if (line.startsWith("Minimum tour lenght: ")) { 
                    currentLength = Integer.parseInt(line.substring(20).trim());
                } else if (line.startsWith("Total computation time: ")) {                                   
                    time = Long.parseLong(line.substring(24).trim());                
                } else if (line.startsWith("Total states examined: ")) {
                     states = Long.parseLong(line.substring(23).trim());                
                } 
                
                line = reader.readLine();
            }

            if (currentLength < 0 || time < 0 || states < 0 ||
                    currentSolution == null) {
                // We are missing some parts of the output!!
                String s = "Output of task " + taskNumber + " not complete!";
                taskErrors.add(s);   
                tasksFailed++;
                return;                
            }
            
            // All interesting bits where in the file...
            totalStatesDone += states;
            totalWorkerTime += time;
        
            if (currentLength < minimum) {
                // It the best solution we've seen so far!
                minimum = currentLength;
                solution = currentSolution;
                printSolution();
            }                

        } catch (FileNotFoundException e) {
            // Could not find the file
            String s = "Output of task " + taskNumber + " not found!";
            taskErrors.add(s);
            tasksFailed++;
        } catch (IOException e) {
            // File was not (completely) readable
            String s = "Output of task " + taskNumber + " not readable!";
            taskErrors.add(s);
            tasksFailed++;
        } 
    }

     /**
      * Print the final result of the application. 
      */
     private void done() {

        // Record the calculation time
        long time = System.currentTimeMillis() - startTime;

        // Print the last status line
        printStatus(false);
        System.out.println();

        // Check if all tasks are done
        if (totalTasks == tasksFinished && tasksFailed == 0) {
            System.out.println("Tasks finished: " + tasksFinished + " (OK)");
        } else {
            System.out.println("Tasks finished: " + tasksFinished + " (!)");
            
            if (totalTasks != tasksFinished) { 
                int missing = totalTasks - tasksFinished;                 
                System.out.println("Tasks missing: " + missing);                    
            }
            
            if (tasksFailed != 0) { 
                System.out.println("Errors in results: " + tasksFailed);
                
                for (int i=0;i<taskErrors.size();i++) { 
                    System.out.println(" - " + taskErrors.get(i));                        
                }                                
            }            
            
            System.exit(1);
        }

        // Print the optimal route
        System.out.print("Optimal route: [" + solution[0]);

        for (int i = 1; i < distanceTable.cities; i++) {
            System.out.print(", " + solution[i]);
        }
        System.out.println("]");
        System.out.println("Route length: " + minimum);

        // Print some interesting statistics
        System.out.println("States examined: " + totalStatesDone);
        System.out.println("Master time: " + (time / 1000) + " sec.");
        System.out.println("Worker time: " + (int)totalWorkerTime + " sec.");        
    }

    public static void main(String args[]) {

        try {
            // Just count parameters and start master.
            if (args.length != 3) {
                System.out
                        .println("Usage: java Server <worker.jar> <tablefile>"
                                + " <workers>");
                System.exit(1);
            }

            TSPMaster master = new TSPMaster(args[0], args[1], Integer
                    .parseInt(args[2]));

            master.start();
            master.done();

        } catch (Exception e) {
            System.out.println("Oops " + e);
            e.printStackTrace();
        }
    }
}
